# 렌더링 파이프라인(Rendering Pipeline: 렌더링의 순서)

![image](https://github.com/SShinMJ/TIL/assets/82142527/e6bba702-8604-43c0-9145-2d15ece788bb)

(이 과정이 매 프레임 일어난다.)

<br>

1. **오브젝트 데이터 받아오기**

   그래픽 카드는 버텍스(Vertex)로 이루어진 물체의 데이터 값을 받아온다. 아직 화면에는 아무것도 존재하지 않고, 그래픽 카드 내부에서 값으로만 존재하는 데이터이다.

   이 버텍스는 필요한 정보들을 가지고 있다. 예를 들면, 버텍스의 인덱스 넘버(Index number), 포지션 (Position), 노말(Normal), 컬러(Color). UV(Texcoord), 접선(Tangent) 등이 있다.

   이것은 아래의 그림처럼 생각할 수 있지만, 이 그림은 이해를 돕기 위해 그린 상상도에 가까우며, 사실은 화면에 존재하지도 않는 숫자의 나열 상태이다.

   ![image](https://github.com/SShinMJ/TIL/assets/82142527/50fdaac3-675f-42dc-94c0-63930f906acf)

   그래픽 카드에서는 이 버텍스의 이 정보들을 가지고 버텍스들을 이어 붙여 삼각형들을 생성해서 면을 생성하게 된다.

   ![image](https://github.com/SShinMJ/TIL/assets/82142527/152fdedd-01a9-4ad0-ba76-ae5d0d9b6abd)

   오브 젝트의 기본적인 형태가 갖추어졌고, 정보들을 버텍스 셰이더로 넘길 준비가 된 것이다.

<br>

2. **정점(버텍스: Vertex) 셰이더**
   
   이제 버텍스 셰이더에서 이 데이터를 가지고 본격적인 셰이딩 작업을 시작한다.

   그 첫 번째 과정이 '정점 셰이더'라고도 부르는 버텍스 셰이더(Vertex Shader)이며, 이 데이터를 이용해서 아래와 같은 좌표 변환을 한다.

   이 작업을 할 때 드디어 셰이더를 통해 그래픽 아티스트들이 데이터에 처음으로 접근하게 되며, 이 부분을 조작해서 각종 버텍스 연산을 마음대로 조절할 수 있다.

   - 로컬 좌표계
     
     ![image](https://github.com/SShinMJ/TIL/assets/82142527/7d460450-40be-4376-aee3-8f409b48dc00)

     버텍스의 위칫값은 초기에는 로컬(Local) 좌표계 상태이다.

    로컬 좌표계란 물체가 가지고 있는 '자기 중심적인' 위치값을 의미한다.

    오브젝트 별로 가지고 있는 본인의 피벗이 0.0.0 위칫값(중심 값)인 상태이다.

    여기에서는 게임 안에 존재할 수 있는 다른 오브젝트의 위치값은 전혀 고려되지 않는다.

    즉, 모든 오브젝트들은 자기가 세상의 중심인 상태이다.

    모든 오브젝트들은 각각의 자신이 세계의 중심이며, 자신이 있는 곳이 원점(0.0.0)이다.

    유니티에서는 이 로컬(Local) 좌표계를 오브젝트(Object) 좌표계라고도 부른다.

   - 월드(모델) 좌표계

     ![image](https://github.com/SShinMJ/TIL/assets/82142527/dcb717e3-5659-4c7b-8868-31638d8b9d37)

     이제 여기에 월드 변환행렬(월드 좌표계)을 곱해줌으로써, 로컬 좌표계를 월드 좌표계로 변환해 준다.

    월드 좌표계란, 절대 좌표인 월드 좌표의 중심점으로부터 각 버텍스의 상대적 위치값을 의미한다.

    월드 좌표계에서는 실제로 이 세계의 **중심점**이 0.0.0이며, 다른 버텍스들은 여기서 **얼마나 떨어져 있는 지로 표현**됩니다.

    유니티에서는 이 월드(World) 좌표계를 모델(Model)이라 한다. 그렇지만 여전히 카메라가 없기 때문에 화면에 출력할 수 없는 상태이다.

   - 카메라 (뷰/시선) 좌표계

     ![image](https://github.com/SShinMJ/TIL/assets/82142527/c6b00b15-9599-44c6-9079-97f06b93a930)

     월드 행렬로 변화된 물체들은 이제 이 월드에 종속되는 위칫값을 가지게 되었다. 그러나 여기에 아직 고려되지 않은 것이 있는데, 바로 '카메라' 다.

    물체가 월드에 존재하고 있는 것은 알겠지만, 카메라가 없으면 화면에 나타나지 않기 때문. 그래서 월드 좌표계의 버텍스들은 이제 다시 '카메라 행렬'에 곱해지고, 그렇게 되면 월드 좌표계에서 살고 있던 오브젝트의 버텍스 위치들이 카메라의 중심점으로부터의 상대적 거리로 다시 연산된다. 즉, 이 세계에서는 카메라의 중심점이 0.0.0이며, 다른 물체들은 여기서 얼마나 상대적으로 떨어져 있는 지로 표현된다.

    드디어 물체들은 화면에 보일 수 있게 되지만, 원근감은 고려되어 있지 않다. 카메라 행렬은 뷰(View)나, 오쏘그래픽 프로젝션(Orthographic Projection)으로 부른다.

    그리고 이 시점부터 카메라가 있으므로 모니터에 출력이 가능한 상태가 된다.

   - 프로젝션 좌표계

     카메라 행렬로 정렬된 버텍스들은 다시 한번 '프로젝션(Projection) 행렬'로 곱해집니다.

     프로젝션 행렬이란 **원근감**을 부여해 주기 위한 방법으로, 카메라에서 **먼 곳은 좁혀진 것처럼 버텍스 위치를 조정**해 주는 것입니다. 사실상으로 카메라에서 멀수록 크기가 작아지는 물체가 되겠지요. 그리고 드디어 우리가 흔히 볼 수 있는 뷰의 모습이 됩니다.

     ![image](https://github.com/SShinMJ/TIL/assets/82142527/9743bcfc-8643-4e8d-98b8-83b73d298918)

<br>

- **버텍스 셰이더 결과**

   여기까지의 작업을 그대로 모니터에 출력한다면 여전히 텍스쳐도 음영도 없는, 말 그대로의 폴리곤 덩어리가 생성된다. 화면에 찍힐 수 있는 준비는 다 되었지만, 아직 이 오브젝트는 픽셀 셰이더를 거치지 않았기 때문에 결과적으로 화면에 출력되지 않아서 우리가 모니터로 볼 수도 없는 단지 3D 공간에서 존재하는 오브젝트일 뿐이다.

   (버텍스 셰이더를 거치고 난 후의 상상도)

   ![image](https://github.com/SShinMJ/TIL/assets/82142527/5bfc4091-458e-4c04-b865-eac924baccdc)

   버텍스 셰이더 단계에서 라이트(Light)를 연산 하게 되면 '버텍스 라이트'라고 하는 매우 가볍고 부정확한 라이트가 연산될 수 있긴하다.

   (고라우드 셰이딩(Gouraud Shading))

   ![image](https://github.com/SShinMJ/TIL/assets/82142527/e7379d5e-821c-452d-99a5-da65a2880b83)

<br>

3. 레스터라이져 (Rasterizer)

   이렇게 좌표계가 조정된 버텍스를 이용해서 화면에 이 오브젝트가 출력될 준비가 됐다면,  모니터에 이 오브젝트를 출력해 줄 필요가 있다. 그래서 이 메쉬가 모니터에서 표현될 때 어느 픽셀로 표현될 것인지를 나타내는 레스터라이져를 거치면 드디어 2D 픽셀로 표현되는 세계로 넘어 오게 되는 것입니다.

   <br>

   이제 **3D는 모니터에 보이도록 '픽셀'이 된 것이다.**

   이 과정을 '**레스터화(Raster化)**'라고 합니다. 이제 **모니터에 보이는 것이 가능해진 것**이죠.

   예를 들어, 3D로 만들 어진 '석고상'을 사진기로 찍는 순간 그 석고상은 2D 이미지가 되듯이, **3D 이미지가 2D 이미지가 되는 순간**입니다.

   모니터에 보이려면 2D 이미지로 만들어야 하니까요.

   (이 모든 작업들이 매 프레임마다 일어납니다. 당연히 화면에는 버텍스보다 픽셀이 더 많으니, 픽셀 셰이더가 버텍스 셰이더보다 더 무거운 것이지요.)

   <br>

   이렇게 수학적인 가상 공간 안에서 입체로 떠돌던 오브젝트는 픽셀이 되고, 드디어 픽셀 셰이더에서 이 픽셀에 접근할 수 있게 되었습니다.

   ![image](https://github.com/SShinMJ/TIL/assets/82142527/7fbcdbbf-8521-4bbd-b9dd-08e74731c45e)

<br>

4. 픽셀 셰이더(Pixel Shader)/프레그먼트 셰이더(Fragment Shader)

  이렇게 모니터까지 넘어온 3D 그래픽 데이터는 본격적으로 화면에 픽셀로 찍히게 된다. 물론 아직 텍스쳐도 없고 라이팅도 없는 상태이다.

  <br>
  
  이제 여기에서 픽셀 셰이더가 가동되면서 조명과 텍스쳐, 그림자와 각종 특수효과 등을 연산하게 된다.
  
  프레그먼트(조각) 셰이더는 픽셀보다도 더 상위의 개념을 말하는 용어이나, 이제 막 시작하는 입장에서는 픽셀과 거의 동일하다라고 하자.

  ![image](https://github.com/SShinMJ/TIL/assets/82142527/1e73db6b-f526-423e-a192-3c491a90afb9)

<br>

유니티 셰이더 그래프의 마스터 스택(Master Stack)(버텍스와 프레그먼트로 나뉘어진 셰이더 그래프의 마스터 스택)

![image](https://github.com/SShinMJ/TIL/assets/82142527/1b1e4e10-05fd-407f-bd53-d479072bcff3)



  


   

  




